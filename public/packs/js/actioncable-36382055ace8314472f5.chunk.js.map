{"version":3,"sources":["webpack:///./node_modules/@rails/actioncable/src/adapters.js","webpack:///./node_modules/@rails/actioncable/src/logger.js","webpack:///./node_modules/@rails/actioncable/src/connection_monitor.js","webpack:///./node_modules/@rails/actioncable/src/internal.js","webpack:///./node_modules/@rails/actioncable/src/connection.js","webpack:///./node_modules/@rails/actioncable/src/subscription.js","webpack:///./node_modules/@rails/actioncable/src/subscription_guarantor.js","webpack:///./node_modules/@rails/actioncable/src/subscriptions.js","webpack:///./node_modules/@rails/actioncable/src/consumer.js","webpack:///./node_modules/@rails/actioncable/src/index.js"],"names":["logger","self","console","WebSocket","log","this","enabled","_len","arguments","length","messages","Array","_key","push","Date","now","adapters","getTime","secondsSince","time","constructor","connection","visibilityDidChange","bind","reconnectAttempts","start","isRunning","startedAt","stoppedAt","startPolling","addEventListener","getPollInterval","stop","stopPolling","removeEventListener","recordPing","pingedAt","recordConnect","disconnectedAt","recordDisconnect","poll","clearTimeout","pollTimeout","setTimeout","reconnectIfStale","_this$constructor$pol","pollInterval","min","max","interval","multiplier","Math","round","number","clamp","connectionIsStale","staleThreshold","disconnectedRecently","reopen","document","visibilityState","isOpen","message_types","protocols","supportedProtocols","slice","indexOf","consumer","open","subscriptions","monitor","disconnected","send","data","webSocket","JSON","stringify","isActive","getState","uninstallEventHandlers","url","installEventHandlers","close","undefined","allowReconnect","error","reopenDelay","getProtocol","protocol","isState","isProtocolSupported","call","states","state","readyState","toLowerCase","eventName","events","handler","prototype","message","event","_JSON$parse","parse","identifier","reason","reconnect","type","welcome","reload","disconnect","ping","confirmation","confirmSubscription","notify","rejection","reject","notifyAll","willAttemptReconnect","Subscription","params","mixin","object","properties","key","value","extend","perform","action","command","unsubscribe","remove","pendingSubscriptions","guarantee","subscription","startGuaranteeing","forget","filter","s","stopGuaranteeing","retrySubscribing","retryTimeout","subscribe","map","guarantor","create","channelName","channel","add","ensureActiveConnection","findAll","sendCommand","callbackName","args","_len2","_key2","_url","createWebSocketURL","connect","test","a","createElement","href","replace","createConsumer","getConfig","default_mount_path","name","element","head","querySelector","getAttribute"],"mappings":"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","file":"js/actioncable-36382055ace8314472f5.chunk.js","sourcesContent":["export default {\n  logger: self.console,\n  WebSocket: self.WebSocket\n};","import adapters from \"./adapters\";\n\n// The logger is disabled by default. You can enable it with:\n//\n//   ActionCable.logger.enabled = true\n//\n//   Example:\n//\n//   import * as ActionCable from '@rails/actioncable'\n//\n//   ActionCable.logger.enabled = true\n//   ActionCable.logger.log('Connection Established.')\n//\n\nexport default {\n  log() {\n    if (this.enabled) {\n      for (var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++) {\n        messages[_key] = arguments[_key];\n      }\n      messages.push(Date.now());\n      adapters.logger.log(\"[ActionCable]\", ...messages);\n    }\n  }\n};","import logger from \"./logger\";\n\n// Responsible for ensuring the cable connection is in good health by validating the heartbeat pings sent from the server, and attempting\n// revival reconnections if things go astray. Internal class, not intended for direct user manipulation.\n\nconst now = () => new Date().getTime();\nconst secondsSince = time => (now() - time) / 1000;\nconst clamp = (number, min, max) => Math.max(min, Math.min(max, number));\nclass ConnectionMonitor {\n  constructor(connection) {\n    this.visibilityDidChange = this.visibilityDidChange.bind(this);\n    this.connection = connection;\n    this.reconnectAttempts = 0;\n  }\n  start() {\n    if (!this.isRunning()) {\n      this.startedAt = now();\n      delete this.stoppedAt;\n      this.startPolling();\n      addEventListener(\"visibilitychange\", this.visibilityDidChange);\n      logger.log(`ConnectionMonitor started. pollInterval = ${this.getPollInterval()} ms`);\n    }\n  }\n  stop() {\n    if (this.isRunning()) {\n      this.stoppedAt = now();\n      this.stopPolling();\n      removeEventListener(\"visibilitychange\", this.visibilityDidChange);\n      logger.log(\"ConnectionMonitor stopped\");\n    }\n  }\n  isRunning() {\n    return this.startedAt && !this.stoppedAt;\n  }\n  recordPing() {\n    this.pingedAt = now();\n  }\n  recordConnect() {\n    this.reconnectAttempts = 0;\n    this.recordPing();\n    delete this.disconnectedAt;\n    logger.log(\"ConnectionMonitor recorded connect\");\n  }\n  recordDisconnect() {\n    this.disconnectedAt = now();\n    logger.log(\"ConnectionMonitor recorded disconnect\");\n  }\n\n  // Private\n\n  startPolling() {\n    this.stopPolling();\n    this.poll();\n  }\n  stopPolling() {\n    clearTimeout(this.pollTimeout);\n  }\n  poll() {\n    this.pollTimeout = setTimeout(() => {\n      this.reconnectIfStale();\n      this.poll();\n    }, this.getPollInterval());\n  }\n  getPollInterval() {\n    const _this$constructor$pol = this.constructor.pollInterval,\n      min = _this$constructor$pol.min,\n      max = _this$constructor$pol.max,\n      multiplier = _this$constructor$pol.multiplier;\n    const interval = multiplier * Math.log(this.reconnectAttempts + 1);\n    return Math.round(clamp(interval, min, max) * 1000);\n  }\n  reconnectIfStale() {\n    if (this.connectionIsStale()) {\n      logger.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, pollInterval = ${this.getPollInterval()} ms, time disconnected = ${secondsSince(this.disconnectedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`);\n      this.reconnectAttempts++;\n      if (this.disconnectedRecently()) {\n        logger.log(\"ConnectionMonitor skipping reopening recent disconnect\");\n      } else {\n        logger.log(\"ConnectionMonitor reopening\");\n        this.connection.reopen();\n      }\n    }\n  }\n  connectionIsStale() {\n    return secondsSince(this.pingedAt ? this.pingedAt : this.startedAt) > this.constructor.staleThreshold;\n  }\n  disconnectedRecently() {\n    return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;\n  }\n  visibilityDidChange() {\n    if (document.visibilityState === \"visible\") {\n      setTimeout(() => {\n        if (this.connectionIsStale() || !this.connection.isOpen()) {\n          logger.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`);\n          this.connection.reopen();\n        }\n      }, 200);\n    }\n  }\n}\nConnectionMonitor.pollInterval = {\n  min: 3,\n  max: 30,\n  multiplier: 5\n};\nConnectionMonitor.staleThreshold = 6; // Server::Connections::BEAT_INTERVAL * 2 (missed two pings)\n\nexport default ConnectionMonitor;","export default {\n  \"message_types\": {\n    \"welcome\": \"welcome\",\n    \"disconnect\": \"disconnect\",\n    \"ping\": \"ping\",\n    \"confirmation\": \"confirm_subscription\",\n    \"rejection\": \"reject_subscription\"\n  },\n  \"disconnect_reasons\": {\n    \"unauthorized\": \"unauthorized\",\n    \"invalid_request\": \"invalid_request\",\n    \"server_restart\": \"server_restart\"\n  },\n  \"default_mount_path\": \"/cable\",\n  \"protocols\": [\"actioncable-v1-json\", \"actioncable-unsupported\"]\n};","import adapters from \"./adapters\";\nimport ConnectionMonitor from \"./connection_monitor\";\nimport INTERNAL from \"./internal\";\nimport logger from \"./logger\";\n\n// Encapsulate the cable connection held by the consumer. This is an internal class not intended for direct user manipulation.\n\nconst message_types = INTERNAL.message_types,\n  protocols = INTERNAL.protocols;\nconst supportedProtocols = protocols.slice(0, protocols.length - 1);\nconst indexOf = [].indexOf;\nclass Connection {\n  constructor(consumer) {\n    this.open = this.open.bind(this);\n    this.consumer = consumer;\n    this.subscriptions = this.consumer.subscriptions;\n    this.monitor = new ConnectionMonitor(this);\n    this.disconnected = true;\n  }\n  send(data) {\n    if (this.isOpen()) {\n      this.webSocket.send(JSON.stringify(data));\n      return true;\n    } else {\n      return false;\n    }\n  }\n  open() {\n    if (this.isActive()) {\n      logger.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`);\n      return false;\n    } else {\n      logger.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${protocols}`);\n      if (this.webSocket) {\n        this.uninstallEventHandlers();\n      }\n      this.webSocket = new adapters.WebSocket(this.consumer.url, protocols);\n      this.installEventHandlers();\n      this.monitor.start();\n      return true;\n    }\n  }\n  close() {\n    let _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        allowReconnect: true\n      },\n      allowReconnect = _ref.allowReconnect;\n    if (!allowReconnect) {\n      this.monitor.stop();\n    }\n    if (this.isActive()) {\n      return this.webSocket.close();\n    }\n  }\n  reopen() {\n    logger.log(`Reopening WebSocket, current state is ${this.getState()}`);\n    if (this.isActive()) {\n      try {\n        return this.close();\n      } catch (error) {\n        logger.log(\"Failed to reopen WebSocket\", error);\n      } finally {\n        logger.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`);\n        setTimeout(this.open, this.constructor.reopenDelay);\n      }\n    } else {\n      return this.open();\n    }\n  }\n  getProtocol() {\n    if (this.webSocket) {\n      return this.webSocket.protocol;\n    }\n  }\n  isOpen() {\n    return this.isState(\"open\");\n  }\n  isActive() {\n    return this.isState(\"open\", \"connecting\");\n  }\n\n  // Private\n\n  isProtocolSupported() {\n    return indexOf.call(supportedProtocols, this.getProtocol()) >= 0;\n  }\n  isState() {\n    for (var _len = arguments.length, states = new Array(_len), _key = 0; _key < _len; _key++) {\n      states[_key] = arguments[_key];\n    }\n    return indexOf.call(states, this.getState()) >= 0;\n  }\n  getState() {\n    if (this.webSocket) {\n      for (let state in adapters.WebSocket) {\n        if (adapters.WebSocket[state] === this.webSocket.readyState) {\n          return state.toLowerCase();\n        }\n      }\n    }\n    return null;\n  }\n  installEventHandlers() {\n    for (let eventName in this.events) {\n      const handler = this.events[eventName].bind(this);\n      this.webSocket[`on${eventName}`] = handler;\n    }\n  }\n  uninstallEventHandlers() {\n    for (let eventName in this.events) {\n      this.webSocket[`on${eventName}`] = function () {};\n    }\n  }\n}\nConnection.reopenDelay = 500;\nConnection.prototype.events = {\n  message(event) {\n    if (!this.isProtocolSupported()) {\n      return;\n    }\n    const _JSON$parse = JSON.parse(event.data),\n      identifier = _JSON$parse.identifier,\n      message = _JSON$parse.message,\n      reason = _JSON$parse.reason,\n      reconnect = _JSON$parse.reconnect,\n      type = _JSON$parse.type;\n    switch (type) {\n      case message_types.welcome:\n        this.monitor.recordConnect();\n        return this.subscriptions.reload();\n      case message_types.disconnect:\n        logger.log(`Disconnecting. Reason: ${reason}`);\n        return this.close({\n          allowReconnect: reconnect\n        });\n      case message_types.ping:\n        return this.monitor.recordPing();\n      case message_types.confirmation:\n        this.subscriptions.confirmSubscription(identifier);\n        return this.subscriptions.notify(identifier, \"connected\");\n      case message_types.rejection:\n        return this.subscriptions.reject(identifier);\n      default:\n        return this.subscriptions.notify(identifier, \"received\", message);\n    }\n  },\n  open() {\n    logger.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`);\n    this.disconnected = false;\n    if (!this.isProtocolSupported()) {\n      logger.log(\"Protocol is unsupported. Stopping monitor and disconnecting.\");\n      return this.close({\n        allowReconnect: false\n      });\n    }\n  },\n  close(event) {\n    logger.log(\"WebSocket onclose event\");\n    if (this.disconnected) {\n      return;\n    }\n    this.disconnected = true;\n    this.monitor.recordDisconnect();\n    return this.subscriptions.notifyAll(\"disconnected\", {\n      willAttemptReconnect: this.monitor.isRunning()\n    });\n  },\n  error() {\n    logger.log(\"WebSocket onerror event\");\n  }\n};\nexport default Connection;","// A new subscription is created through the ActionCable.Subscriptions instance available on the consumer.\n// It provides a number of callbacks and a method for calling remote procedure calls on the corresponding\n// Channel instance on the server side.\n//\n// An example demonstrates the basic functionality:\n//\n//   App.appearance = App.cable.subscriptions.create(\"AppearanceChannel\", {\n//     connected() {\n//       // Called once the subscription has been successfully completed\n//     },\n//\n//     disconnected({ willAttemptReconnect: boolean }) {\n//       // Called when the client has disconnected with the server.\n//       // The object will have an `willAttemptReconnect` property which\n//       // says whether the client has the intention of attempting\n//       // to reconnect.\n//     },\n//\n//     appear() {\n//       this.perform('appear', {appearing_on: this.appearingOn()})\n//     },\n//\n//     away() {\n//       this.perform('away')\n//     },\n//\n//     appearingOn() {\n//       $('main').data('appearing-on')\n//     }\n//   })\n//\n// The methods #appear and #away forward their intent to the remote AppearanceChannel instance on the server\n// by calling the `perform` method with the first parameter being the action (which maps to AppearanceChannel#appear/away).\n// The second parameter is a hash that'll get JSON encoded and made available on the server in the data parameter.\n//\n// This is how the server component would look:\n//\n//   class AppearanceChannel < ApplicationActionCable::Channel\n//     def subscribed\n//       current_user.appear\n//     end\n//\n//     def unsubscribed\n//       current_user.disappear\n//     end\n//\n//     def appear(data)\n//       current_user.appear on: data['appearing_on']\n//     end\n//\n//     def away\n//       current_user.away\n//     end\n//   end\n//\n// The \"AppearanceChannel\" name is automatically mapped between the client-side subscription creation and the server-side Ruby class name.\n// The AppearanceChannel#appear/away public methods are exposed automatically to client-side invocation through the perform method.\n\nconst extend = function (object, properties) {\n  if (properties != null) {\n    for (let key in properties) {\n      const value = properties[key];\n      object[key] = value;\n    }\n  }\n  return object;\n};\nexport default class Subscription {\n  constructor(consumer) {\n    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let mixin = arguments.length > 2 ? arguments[2] : undefined;\n    this.consumer = consumer;\n    this.identifier = JSON.stringify(params);\n    extend(this, mixin);\n  }\n\n  // Perform a channel action with the optional data passed as an attribute\n  perform(action) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    data.action = action;\n    return this.send(data);\n  }\n  send(data) {\n    return this.consumer.send({\n      command: \"message\",\n      identifier: this.identifier,\n      data: JSON.stringify(data)\n    });\n  }\n  unsubscribe() {\n    return this.consumer.subscriptions.remove(this);\n  }\n}","import logger from \"./logger\";\n\n// Responsible for ensuring channel subscribe command is confirmed, retrying until confirmation is received.\n// Internal class, not intended for direct user manipulation.\n\nclass SubscriptionGuarantor {\n  constructor(subscriptions) {\n    this.subscriptions = subscriptions;\n    this.pendingSubscriptions = [];\n  }\n  guarantee(subscription) {\n    if (this.pendingSubscriptions.indexOf(subscription) == -1) {\n      logger.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`);\n      this.pendingSubscriptions.push(subscription);\n    } else {\n      logger.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`);\n    }\n    this.startGuaranteeing();\n  }\n  forget(subscription) {\n    logger.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`);\n    this.pendingSubscriptions = this.pendingSubscriptions.filter(s => s !== subscription);\n  }\n  startGuaranteeing() {\n    this.stopGuaranteeing();\n    this.retrySubscribing();\n  }\n  stopGuaranteeing() {\n    clearTimeout(this.retryTimeout);\n  }\n  retrySubscribing() {\n    this.retryTimeout = setTimeout(() => {\n      if (this.subscriptions && typeof this.subscriptions.subscribe === \"function\") {\n        this.pendingSubscriptions.map(subscription => {\n          logger.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`);\n          this.subscriptions.subscribe(subscription);\n        });\n      }\n    }, 500);\n  }\n}\nexport default SubscriptionGuarantor;","import Subscription from \"./subscription\";\nimport SubscriptionGuarantor from \"./subscription_guarantor\";\nimport logger from \"./logger\";\n\n// Collection class for creating (and internally managing) channel subscriptions.\n// The only method intended to be triggered by the user is ActionCable.Subscriptions#create,\n// and it should be called through the consumer like so:\n//\n//   App = {}\n//   App.cable = ActionCable.createConsumer(\"ws://example.com/accounts/1\")\n//   App.appearance = App.cable.subscriptions.create(\"AppearanceChannel\")\n//\n// For more details on how you'd configure an actual channel subscription, see ActionCable.Subscription.\n\nexport default class Subscriptions {\n  constructor(consumer) {\n    this.consumer = consumer;\n    this.guarantor = new SubscriptionGuarantor(this);\n    this.subscriptions = [];\n  }\n  create(channelName, mixin) {\n    const channel = channelName;\n    const params = typeof channel === \"object\" ? channel : {\n      channel\n    };\n    const subscription = new Subscription(this.consumer, params, mixin);\n    return this.add(subscription);\n  }\n\n  // Private\n\n  add(subscription) {\n    this.subscriptions.push(subscription);\n    this.consumer.ensureActiveConnection();\n    this.notify(subscription, \"initialized\");\n    this.subscribe(subscription);\n    return subscription;\n  }\n  remove(subscription) {\n    this.forget(subscription);\n    if (!this.findAll(subscription.identifier).length) {\n      this.sendCommand(subscription, \"unsubscribe\");\n    }\n    return subscription;\n  }\n  reject(identifier) {\n    return this.findAll(identifier).map(subscription => {\n      this.forget(subscription);\n      this.notify(subscription, \"rejected\");\n      return subscription;\n    });\n  }\n  forget(subscription) {\n    this.guarantor.forget(subscription);\n    this.subscriptions = this.subscriptions.filter(s => s !== subscription);\n    return subscription;\n  }\n  findAll(identifier) {\n    return this.subscriptions.filter(s => s.identifier === identifier);\n  }\n  reload() {\n    return this.subscriptions.map(subscription => this.subscribe(subscription));\n  }\n  notifyAll(callbackName) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    return this.subscriptions.map(subscription => this.notify(subscription, callbackName, ...args));\n  }\n  notify(subscription, callbackName) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n      args[_key2 - 2] = arguments[_key2];\n    }\n    let subscriptions;\n    if (typeof subscription === \"string\") {\n      subscriptions = this.findAll(subscription);\n    } else {\n      subscriptions = [subscription];\n    }\n    return subscriptions.map(subscription => typeof subscription[callbackName] === \"function\" ? subscription[callbackName](...args) : undefined);\n  }\n  subscribe(subscription) {\n    if (this.sendCommand(subscription, \"subscribe\")) {\n      this.guarantor.guarantee(subscription);\n    }\n  }\n  confirmSubscription(identifier) {\n    logger.log(`Subscription confirmed ${identifier}`);\n    this.findAll(identifier).map(subscription => this.guarantor.forget(subscription));\n  }\n  sendCommand(subscription, command) {\n    const identifier = subscription.identifier;\n    return this.consumer.send({\n      command,\n      identifier\n    });\n  }\n}","import Connection from \"./connection\";\nimport Subscriptions from \"./subscriptions\";\n\n// The ActionCable.Consumer establishes the connection to a server-side Ruby Connection object. Once established,\n// the ActionCable.ConnectionMonitor will ensure that its properly maintained through heartbeats and checking for stale updates.\n// The Consumer instance is also the gateway to establishing subscriptions to desired channels through the #createSubscription\n// method.\n//\n// The following example shows how this can be set up:\n//\n//   App = {}\n//   App.cable = ActionCable.createConsumer(\"ws://example.com/accounts/1\")\n//   App.appearance = App.cable.subscriptions.create(\"AppearanceChannel\")\n//\n// For more details on how you'd configure an actual channel subscription, see ActionCable.Subscription.\n//\n// When a consumer is created, it automatically connects with the server.\n//\n// To disconnect from the server, call\n//\n//   App.cable.disconnect()\n//\n// and to restart the connection:\n//\n//   App.cable.connect()\n//\n// Any channel subscriptions which existed prior to disconnecting will\n// automatically resubscribe.\n\nexport default class Consumer {\n  constructor(url) {\n    this._url = url;\n    this.subscriptions = new Subscriptions(this);\n    this.connection = new Connection(this);\n  }\n  get url() {\n    return createWebSocketURL(this._url);\n  }\n  send(data) {\n    return this.connection.send(data);\n  }\n  connect() {\n    return this.connection.open();\n  }\n  disconnect() {\n    return this.connection.close({\n      allowReconnect: false\n    });\n  }\n  ensureActiveConnection() {\n    if (!this.connection.isActive()) {\n      return this.connection.open();\n    }\n  }\n}\nexport function createWebSocketURL(url) {\n  if (typeof url === \"function\") {\n    url = url();\n  }\n  if (url && !/^wss?:/i.test(url)) {\n    const a = document.createElement(\"a\");\n    a.href = url;\n    // Fix populating Location properties in IE. Otherwise, protocol will be blank.\n    a.href = a.href;\n    a.protocol = a.protocol.replace(\"http\", \"ws\");\n    return a.href;\n  } else {\n    return url;\n  }\n}","import Connection from \"./connection\";\nimport ConnectionMonitor from \"./connection_monitor\";\nimport Consumer, { createWebSocketURL } from \"./consumer\";\nimport INTERNAL from \"./internal\";\nimport Subscription from \"./subscription\";\nimport Subscriptions from \"./subscriptions\";\nimport SubscriptionGuarantor from \"./subscription_guarantor\";\nimport adapters from \"./adapters\";\nimport logger from \"./logger\";\nexport { Connection, ConnectionMonitor, Consumer, INTERNAL, Subscription, Subscriptions, SubscriptionGuarantor, adapters, createWebSocketURL, logger };\nexport function createConsumer() {\n  let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getConfig(\"url\") || INTERNAL.default_mount_path;\n  return new Consumer(url);\n}\nexport function getConfig(name) {\n  const element = document.head.querySelector(`meta[name='action-cable-${name}']`);\n  if (element) {\n    return element.getAttribute(\"content\");\n  }\n}"],"sourceRoot":""}